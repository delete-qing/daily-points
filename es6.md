# Es6 知识点

### 取值

#### 取值在程序中非常常见，比如从对象 obj 中取值。

```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
  e: 5,
};

const { a, b, c, d, e } = obj;
```

#### es6 的解构赋值可以这样用

```js
setup(){
    const state =reactive(
        {
            name:'张',
            age:18,
        }
    ),
    const getData=()=>{
       let {name,age} = state
       if(name==18)  return;
    }
}
```

#### 补充

ES6 的解构赋值虽然好用。但是要注意解构的对象不能为 undefined、null。否则会报错，故要给被解构的对象一个默认值。

```js
const { a, b, c, d, e } = obj || {};
```

### 合并数据

#### 比如合并两个数组，合并两个对象。

ES6 的扩展运算符是不是忘记了，还有数组的合并不考虑去重吗？

```js
const a = [1, 2, 3];
const b = [1, 5, 6];
const c = [...new Set([...a, ...b])]; //[1,2,3,5,6]

const obj1 = {
  a: 1,
};
const obj2 = {
  b: 1,
};
const obj = { ...obj1, ...obj2 }; //{a:1,b:1}
```

### 拼接字符串

#### 在${}中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。

```js
const name = "小明";
const score = 59;
const result = `${name}${score > 60 ? "的考试成绩及格" : "的考试成绩不及格"}`;
```

### if 中判断

#### ES6 中数组实例方法 includes

```js
const condition = [1, 2, 3, 4];

if (condition.includes(type)) {
  //...
}
```

### 扁平化数组

#### 一个部门 JSON 数据中，属性名是部门 id，属性值是个部门成员 id 数组集合，现在要把有部门的成员 id 都提取到一个数组集合中。

其中使用 Infinity 作为 flat 的参数，使得无需知道被扁平化的数组的维度。

```js
const deps = {
  采购部: [1, 2, 3],
  人事部: [5, 8, 12],
  行政部: [5, 14, 79],
  运输部: [3, 64, 105],
};
let member = Object.values(deps).flat(Infinity);
```


##### **es5和es6的区别，说一下你所知道的es6**

- let声明变量和const声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明
- 箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义
- 模板字符串模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串
- 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值
- for of循环for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串
- import、export导入导出，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用
- set数据结构Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数
- 展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量
- class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念
- async、await使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程,
- Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大
- SymbolSymbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的
- Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情

##### **var、let、const之间的区别**

- var会与window相映射（会挂一个属性），而let不与window相映射
- const声明之后必须赋值，否则会报错
- const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错

##### **箭头函数**

- 用了箭头函数，this就不是指向window，而是父级（指向是可变的）

- 不能够使用arguments对象

- 不能够使用new命令，否则会抛出一个错误

- 指向与上下文有关  指哪打哪

  何时在 ES6 中使用箭头函数？

  - 在全局作用域内和`Object.prototype`属性中使用 `function` 
  - 为对象构造函数使用 `class`

  优点：

  - **作用域安全性**:当箭头函数被一致使用时，所有东西都保证使用与根对象相同的`this.Object`。
  - 如果一个标准函数回调与一堆箭头函数混合在一起，那么作用域就有可能变得混乱。
  - **紧凑性**:箭头函数更容易读写。
  - 清晰度:使用箭头函数可明确知道当前 `this` 指向。
  
  什么时候不使用箭头函数?
  
  - 当想要函数被提升时(箭头函数是匿名的)
  - 要在函数中使用`this/arguments`时，由于箭头函数本身不具有`this/arguments`，因此它们取决于外部上下文

##### `.call` 和 `.apply` 区别是啥？

- `.call`和`.apply`均用于调用函数，并且第一个参数将用作函数中`this`的值
- `.call`将逗号分隔的参数作为下一个参数，
- `apply`将参数数组作为下一个参数

```js
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3  
```



##### **ES6的模板字符串有哪些新特性**

- 基本的字符串格式化。
- 将表达式嵌入字符串中进行拼接。
- ES6反引号(``)就能解决类模板字符串的功能

##### **介绍下 Set、Map的区别？**

应用场景Set用于数据重组，Map用于数据储存Set：　

- 成员不能重复
- 只有键值没有键名，类似数组
- 可以遍历，方法有add, delete,has

Map:

- 本质上是健值对的集合，类似集合
- 可以遍历，可以跟各种数据格式转换

##### **orEach、for in、for of三者区别**

- forEach更多的用来遍历数组
- for in 一般常用来遍历对象或json
- for of数组对象都可以遍历，遍历对象需要通过和Object.keys()
- for in循环出的是key，for of循环出的是value

##### 什么是 IIFE (立即调用的函数表达式)

`IIFE`是一个立即调用的函数表达式，它在创建后立即执行

常常使用此模式来避免污染全局命名空间，因为在`IIFE`中使用的所有变量(与任何其他普通函数一样)在其作用域之外都是不可见的。

```js
(function IIFE(){
    console.log( "Hello!" );
})();
// "Hello!
```









