### **JavaScript 中的相等性判断**

###### **ES2015中有四种相等算法：**

- 抽象（非严格）相等比较 (`==`)
- 严格相等比较 (`===`): 用于  `Array.prototype.indexOf`, `Array.prototype.lastIndexOf`, 和 `case`-matching
- 同值零: 用于 `%TypedArray%` 和 `ArrayBuffer `构造函数、以及`Map`和`Set`操作, 并将用于 ES2016/ES7 中的`String.prototype.includes`
- 同值: 用于所有其他地方

##### **JavaScript提供三种不同的值比较操作**

###### 一、**严格相等（也被称作"strict equality", "identity", "triple equals")**

- 全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的
- 如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等
- 如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。

###### 二、**非严格相等（抽象相等比较 ("loose equality"，"double equals")**

- 相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。
- 在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 === 的比较方式
- 一般而言，根据 ECMAScript 规范，所有的对象都与 `undefined `和 `null `不相等，但是大部分浏览器允许非常窄的一类对象（即，所有页面中的`document.all `对象），在某些情况下，充当效仿 `undefined `的角色。相等操作符就是在这样的一个背景下，在其他所有情况下，一个对象都不会等于 `undefined `或 `null`
- 有些开发者认为，最好永远都不要使用相等操作符。全等操作符的结果更容易预测，并且因为没有隐式转换，全等比较的操作会更快。

###### 三、 **Object.is（ECMAScript 2015/ ES6 新特性)**

- [`Object.is`]并不比双等更宽松，也并不比三等更严格
- 可以区分 `-0` 和 `+0`, `0,0`, true,  `+0,-0` false,
- [`Object.is`] 处理 [`NaN`的不同。 `Object.is(NaN, NaN)` 被计算成 `true`

###### **同值**

- 同值相等由 [`Object.is`]方法提供。

###### **同值零**

- 与同值相等类似，不过会认为 +0 与 -0 相等。

###### **什么时候使用 `Object.is`或是三等**

- 关于属性描述器，即你的工作需要去镜像[`Object.defineProperty`]的一些特性时
- 工作不需要这些，那你应该避免使用[`Object.is`]，使用[`===`]来代替，即使你需要比较两个[`NaN`]使其结果为`true`
- 总的来说编写使用[`NaN`]检查的特例函数不影响不同符号的0的比较更容易些

###### **选择使用哪个操作取决于你需要什么样的比较。**

- 在比较两件事情时，双等(`==`)号将执行类型转换;
- 三等(`===`)号将进行相同的比较，而不进行类型转换(如果类型不同, 只是总会返回 false )
- 而Object.is的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以-0和+0为`false`，而Object.is（NaN，NaN）将为 `true`
- 通常使用双等号或三等号将NaN与NaN进行比较，结果为false
- 所有这些之间的区别都与其处理原语有关; 这三个运算符的原语中，没有一个会比较两个变量是否结构上概念类似。对于任意两个不同的非原始对象，即便他们有相同的结构， 以上三个运算符都会计算得到 false 。




| 被比较值 B |           |           |                       |                               |                                 |                                 |              |
| :--------- | --------- | --------- | --------------------- | ----------------------------- | ------------------------------- | ------------------------------- | ------------ |
|            |           | Undefined | Null                  | Number                        | String                          | Boolean                         | Object       |
| 被比较值 A | Undefined | `true`    | `true`                | `false`                       | `false`                         | `false`                         | `IsFalsy(B)` |
| Null       | `true`    | `true`    | `false`               | `false`                       | `false`                         | `IsFalsy(B)`                    |              |
| Number     | `false`   | `false`   | `A === B`             | `A === ToNumber(B)`           | `A=== ToNumber(B)`              | `A== ToPrimitive(B)`            |              |
| String     | `false`   | `false`   | `ToNumber(A) === B`   | `A === B`                     | `ToNumber(A) === ToNumber(B)`   | `ToPrimitive(B) == A`           |              |
| Boolean    | `false`   | `false`   | `ToNumber(A) === B`   | `ToNumber(A) === ToNumber(B)` | `A === B`                       | `ToNumber(A) == ToPrimitive(B)` |              |
| Object     | `false`   | `false`   | `ToPrimitive(A) == B` | `ToPrimitive(A) == B`         | `ToPrimitive(A) == ToNumber(B)` | `A === B`                       |              |



#####  **display:none 与 visibility：hidden 的区别**

display: none ：该元素以及它的所有后代元素都会隐藏,，不会占据后面的空间

visibility: hidden：隐藏占空间，visibility具有继承性

##### **伪类**

伪类由一个冒号`:`开头，是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息

获取不存在与DOM树中的信息。比如`<a>`标签的`:link`、`visited`等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取

##### **伪元素**

伪元素的由两个冒号`::`开头，在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的，

一些伪元素可以使开发者获取到不存在于源文档中的内容（比如常见的`::before`,`::after`）

一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。

##### **伪类与伪元素的特性及其区别**

1. 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；
2. 伪元素本质上是创建了一个有内容的虚拟容器；
3. CSS3中伪类和伪元素的语法不同；
4. 可以同时使用多个伪类，而只能同时使用一个伪元素；

##### **map和filter区别   map和filter都不会改变原数组。**

**map()** 

1. 会根据提供的函数对指定序列做映射。 map不是“地图”的意思，而是指“映射”

1. 不会对空数组进行检测。具有极快的查找速度
  2. 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
  3. 就是map函数之后，数组元素个数不变，但是按照一定的条件转换，数组元素发生了变化

**filter()** 

1. 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表

1. filter可过滤NaN、null、undefined、0

2. 数组元素个数可能发生了改变，但是数组元素不会发生改变。

   

**map,filter方法都会对数组所有元素进行一次转换**

###### **当你需要拷贝一个数组的全部或者部分到一个新数组的时候，优先使用map和filter而不是forEach**

- 关注点分离：过滤和改变数据的格式是两个不相关的关注点，对两个关注点分别使用各自的方法可以达到关注点分离的目的。
- 易于测试：两种目的都使用了简单的纯函数，使得各种行为的单元测试变得简单。值得一提的是最初的实现版本并不是纯粹的，因为依赖一些作用域外边的状态（keys数组）。
- 可读性：因为这两个方法有明确的目的，一个是过滤数据，一个是改变数据的格式，所以很容易看出对数据做了哪些处理。尤其是像reduce这样的同类函数。
- 异步编程：forEach和async/await不能很好地结合在一起。但是map提供了一种有用的模式，可以和promises和async/await一起使用

##### **map和set区别 **

​	**set()**

  1. 不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。重复元素在`Set`中自动被过滤：

  2. Set.has(x) 是 set 中的一个方法。即判断当前 set 中是否含有 x，如果有返回 true，没有返回 false。

###### **判断一个变量是数组有几种方式**

1. Object.prototype.toString，通过object类型的副属性class去判断的其中函数的class是Function，结果是[object Function]， 普通的对象是Object，结果是[object Object]，写法：Object.prototype.toString.call(变量) === '[object Array]'

2. Array.isArray，es6新增的方法，写法：Array.isArray(变量)

###### **事件代理、事件冒泡、事件捕获是什么**

**事件代理：**又称之为事件委托，是JavaScript中常用绑定事件的常用技巧。“事件代理”是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。

**事件代理优点：**

1. 可以大量节省内存占用，减少事件注册；
2. 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）。

一个事件触发后，会在子元素和父元素之间传播（propagation），这种传播分成三个阶段

- **捕获阶段：**从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；
- **目标阶段：**在目标节点上触发，称为“目标阶段”
- **冒泡阶段：**从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层。

###### **axios 原理**

axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。axios可以用在浏览器和 node.js 中是因为，它会自动判断当前环境是什么，如果是浏览器，就会基于XMLHttpRequests实现axios。如果是node.js环境，就会基于node内置核心模块http实现axios。

- XMLHttpRequest 是浏览器内置的一个对象，它为客户端提供了在客户端和服务器之间传输数据的功能。
- process 对象是node内置的一个全局变量，提供有关信息，控制当前 Node.js 进程。通过判断process是否存在，来判断是否是node环境

###### **什么是跨域？如何处理？**

当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域。

- 出于浏览器的同源策略限制
- 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）

**解决方法**(了解下)

**1. 设置document.domain解决无法读取非同源网页的 Cookie问题**

-  因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）

**2. 跨文档通信 API：window.postMessage()**(这个要百度下)

 - 调用postMessage方法实现父窗口
 - 页面和其打开的新窗口的数据传递
 - 多窗口之间消息传递
 - 页面与嵌套的iframe消息传递 
 - 上面三个场景的跨域数据传递

**3. JSONP**

SONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。
核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来

**4. CORS**

CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。
普通跨域请求：只需服务器端设置Access-Control-Allow-Origin
带cookie跨域请求：前后端都需要进行设置（根据xhr.withCredentials字段判断是否带有cookie）

###### **路由原理**

路由分为后端路由和前端路由。

**后端路由**

- 又称服务器端路由，当服务器收到客户端发来的HTTP请求，就会根据请求的URL，来找到相应的映射函数，然后执行该函数，将执行结果的返回值发送给客户端。
- 对于最简单的静态资源服务器，可以认为，所有的URL的映射函数就是一个文件读取操作
- 对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据操作，然后根据读取的数据，在服务器端就使用相应的模块来对页面进行渲染后，再返回渲染完毕的页面。这种方式在早期的前端开发中非常普遍，像京东的页面就是一个后端路由，他请求的是一个页面

优点：安全性好，SEO好。

缺点：加大服务器的压力，不利于用户体验，代码冗合。

**前端路由**

- URL到函数的映射。路由的映射函数通常是进行一些DOM的显示隐藏操作。当访问不同路径时，就会显示不同的页面组件。

优点：访问不同页面时，仅仅只是变换了路径而已，没有网络延迟，提升了用户体验。

缺点：使用浏览器的前进后退时，会重新发送请求，没有合理的利用缓存，不利于SEO



**前端路由主要有两种实现方案：hash、history API**

**hash**

- hash实现就是基于location.hash来实现的
- location.hash的值就是URL中#后面的内容。

**history**

- 更美观的实现URL的变化
- history.pushState()、history.replaceState()。不刷新的情况下，操作浏览器的历史记录。
- pushState()是会增加新的历史记录，而replaceState()是替换当前的历史记录。

**区别**

| hash                                                   | history                                                      |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| 兼容更好                                               | 更正式美观                                                   |
| 只修改#后面内容                                        | 可以设置同源下任意URL                                        |
| 新值不能与旧值相同，一样的不会触发动作将记录添加到栈中 | 新旧值可以相同，pushSate该添加的会添加到栈中                 |
| 对服务器无需改动                                       | 刷新时，若服务器没有响应数据或资源，会404。需要对服务器做一些改造，对不同的路由进行相应的设置。 |
| 即不会发送请求                                         | 会向服务器发送请求，避免404服务器应该做处理。当匹配不到资源时，应返回同一个html页面 |

##### **Promise 中reject 和 catch 处理上有什么区别**

- reject 是用来抛出异常，catch 是用来处理异常
- reject 是 Promise 的方法，而 catch 是 Promise `实例的方法`
- reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch
- 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调

##### promise原理

promise构造函数是同步执行的，then方法是异步执行的

Promise 是异步编程的一种解决方案：

- 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；

- 从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。
- promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。

基本过程：

- 初始化 Promise 状态（pending）

- 立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理

- 执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）

- Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。

**真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.**

##### async await原理

- async函数就是generator函数的**语法糖**，是用来解决异步的，将generator函数的*换成async，将yield替换成await

- async函数返回一个 Promise 对象，可以使用then方法添加回调函数
  当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句

async函数对generator的改进：

- 内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。

- 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
- 更广的适用性
- 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。

###### 语法糖：

用更简练的言语表达较复杂的含义，语法糖就是一种便捷写法。程序更加简洁，有更高的可读性。

```js
//最基本的，for循环就是一个语法糖：
for (var i = 0; i < 5; i++){
    ... 
}
```

##### 虚拟DOM

- 虚拟 DOM 的本质就是 JavaScript 对 象，使用 JavaScript 对象来描述 DOM 的结构。应用的各种状态变化首先作用于虚拟 DOM，最终映射 到 DOM。
- 前端性能优化的一个秘诀就是尽可能少地操作DOM，因为频繁变动DOM会造成浏览器的回流或者重回
- 手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码
- 省略手动DOM操作可以大大提高开发效率.

##### **javascript中的类，实例化**

什么是类：

- 描述具有相同属性或者方法的对象的集合。

- 类本身指向其构造函数。

- 类的属性分为：类本身的属性，类的构造函数的属性，类的原型对象的属性

- 类的方法也是有以上三种

- 实例化的时候实例能获取到类的构造函数与原型对象上的属性与方法，但是不能获取类本身的属性和方法

- 实例的构造函数是类本身，实例的原型指向类的原型对象，类的原型对象的构造函数就是类本身

  ```js
  p.constructor == p.__proto__.constructor // true 
  ```

什么是实例化：

- 将抽象的类转为具体的对象。
- 原型对象-prototype:无论什么时候，只要创建了一个**函数**，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。
- 只有函数才会有原型对象，对象是没有的

那么实例是如何得到类的方法以及属性的呢？

首先就是new干了什么：

- 创建一个新对象。

- 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）

- 执行构造函数中的代码。（为这个对象添加属性）。

- 返回这个对象。

  

通常把用类创建对象的过程称为实例化，实例化对象就是创建对象的过程

两个相关的概念：
类：比如 人类 （对象的模板、实物的共同特征）
通过关键字：new （在JS中是没有“类”这个概念的，而是用构造函数来作为对象模版的）
实例：比如 王小二 （
那么，王小二的父母孕育他直到出生的过程，就叫：实例化







